generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id            Int      @id @default(autoincrement())
  firstName     String
  lastName      String
  email         String   @unique
  password      String?
  googleId      String? // âœ… add this
  profileImage  Bytes?
  profileImgUrl String?
  createdAt     DateTime @default(now())
  twoFASecret   String?
  is2FAEnabled  Boolean  @default(false)
  isVerified    Boolean  @default(false)
  updatedAt     DateTime @updatedAt

  // New fields
  plan               String  @default("Free")
  hasPurchasedBefore Boolean @default(false)
  contactLimit       Int     @default(50)
  emailLimit         Int     @default(50)
  smsCredits         Int?    @default(0) // âœ… NEW
  whatsappCredits    Int?    @default(0) // âœ… NEW

  // Relations (leave them as-is)
  apiKeys             ApiKey[]
  contents            Content[]
  verificationTokens  EmailVerificationToken[]
  inAppNotifications  InAppNotification[]
  loginLogs           LoginLog[]
  notificationSetting NotificationSetting?
  otpCodes            OTPCode[]
  passwordResetTokens PasswordResetToken[]     @relation("UserTokens")
  sessions            Session[]
  Contact             Contact[]
  emailAccounts       EmailAccount[]
  Payment             Payment[]
  Task                Task[]
  Deal                Deal[]
  Lead                Lead[]
  List                List[]
  Order               Order[]
  VerificationBatch   VerificationBatch[]
  Verification        Verification[]
  Campaign            Campaign[]
  CampaignEvent       CampaignEvent[]
  VerifiedSender      VerifiedSender[]
  ScheduledCampaign   ScheduledCampaign[]
  BatchResult         BatchResult[]
  CustomRecord        CustomRecord[]

  // ðŸ”¹ NEW RELATIONS for Twilio Integration
  twilioConfig      TwilioConfig?
  whatsappCampaigns WhatsappCampaign[]
  smsCampaigns      SmsCampaign[]
  AutomationLog     AutomationLog[]
}

model Content {
  id           Int      @id @default(autoincrement())
  title        String
  description  String?
  animationUrl String?
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  createdBy    Int
  user         User     @relation(fields: [createdBy], references: [id])
}

model Session {
  id        Int      @id @default(autoincrement())
  userId    Int
  device    String
  ipAddress String
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id])
}

model LoginLog {
  id        Int      @id @default(autoincrement())
  userId    Int
  device    String
  ipAddress String
  location  String?
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id])
}

model EmailVerificationToken {
  id        Int      @id @default(autoincrement())
  token     String
  userId    Int
  expiresAt DateTime
  user      User     @relation(fields: [userId], references: [id])
}

model OTPCode {
  id        Int      @id @default(autoincrement())
  code      String
  userId    Int
  expiresAt DateTime
  user      User     @relation(fields: [userId], references: [id])
}

model SupportMessage {
  id        Int      @id @default(autoincrement())
  name      String
  message   String
  createdAt DateTime @default(now())
  userEmail String?
  userId    Int?
}

model SupportTicket {
  id          Int           @id @default(autoincrement())
  subject     String
  description String
  createdAt   DateTime      @default(now())
  userEmail   String?
  userId      Int?
  files       SupportFile[]
}

model SupportFile {
  id        Int           @id @default(autoincrement())
  filename  String
  mimetype  String
  data      Bytes
  createdAt DateTime      @default(now())
  ticketId  Int
  ticket    SupportTicket @relation(fields: [ticketId], references: [id], onDelete: Cascade)
}

model NotificationSetting {
  id        Int     @id @default(autoincrement())
  userId    Int     @unique
  email     Boolean @default(true)
  sms       Boolean @default(false)
  frequency String  @default("daily")
  user      User    @relation(fields: [userId], references: [id])
}

model InAppNotification {
  id        Int      @id @default(autoincrement())
  userId    Int
  title     String
  message   String
  read      Boolean  @default(false)
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id])
}

model ApiKey {
  id        Int      @id @default(autoincrement())
  key       String   @unique
  name      String
  createdAt DateTime @default(now())
  revoked   Boolean  @default(false)
  userId    Int
  user      User     @relation(fields: [userId], references: [id])
}

model DeletedAccount {
  id        Int      @id @default(autoincrement())
  userEmail String
  reason    String?
  deletedAt DateTime @default(now())
}

model PasswordResetToken {
  id        Int      @id @default(autoincrement())
  token     String   @unique
  createdAt DateTime @default(now())
  userId    Int
  user      User     @relation("UserTokens", fields: [userId], references: [id], onDelete: Cascade)
  expiresAt DateTime
}

model Contact {
  id        Int      @id @default(autoincrement())
  name      String?
  email     String?
  phone     String?
  company   String?
  status    String?  @default("active")
  priority  String? // vip, subscriber, new, etc.
  last      String?
  userId    Int?
  user      User?    @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  replies   Reply[]

  @@unique([email, userId])
}

model Task {
  id       Int      @id @default(autoincrement())
  title    String
  due      DateTime
  status   String
  priority String
  notes    String?
  userId   Int
  user     User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Deal {
  id        Int      @id @default(autoincrement())
  name      String
  client    String
  stage     String
  value     Float
  closing   DateTime
  status    String
  userId    Int
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model EmailAccount {
  id       Int     @id @default(autoincrement())
  userId   Int? // optional foreign key
  email    String  @unique
  provider String?
  authType String
  imapHost String
  imapPort Int
  imapUser String

  smtpHost      String
  smtpPort      Int
  smtpUser      String
  encryptedPass String?

  oauthClientId     String?
  oauthClientSecret String?
  refreshToken      String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Optional relation to User
  user   User?   @relation(fields: [userId], references: [id])
  emails Email[]
}

model Email {
  id        Int @id @default(autoincrement())
  accountId Int

  messageId String  @unique
  threadId  String?
  inReplyTo String?

  from     String
  to       String
  subject  String
  body     String
  bodyHtml String?

  date   DateTime
  folder String   @default("INBOX")
  status String   @default("unread")
  source String   @default("imap")
  tags   String[] @default([])

  isReply Boolean @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // âœ… Added onDelete: Cascade here
  account EmailAccount @relation(fields: [accountId], references: [id], onDelete: Cascade)

  attachments Attachment[]
}

model Attachment {
  id       Int    @id @default(autoincrement())
  emailId  Int
  email    Email  @relation(fields: [emailId], references: [id], onDelete: Cascade)
  filename String
  mimetype String
  size     Int
  data     Bytes

  createdAt DateTime @default(now())
}

model Reply {
  id        Int      @id @default(autoincrement())
  contactId Int
  fromEmail String // who replied (client email)
  toEmail   String // your campaign fromEmail
  subject   String?
  message   String
  createdAt DateTime @default(now())

  contact Contact @relation(fields: [contactId], references: [id])
}

model Lead {
  id        Int      @id @default(autoincrement())
  name      String
  email     String   @unique
  company   String
  source    String
  status    String
  score     Int
  last      String
  userId    Int
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())
}

model List {
  id           String   @id @default(uuid())
  name         String
  count        Int
  email        String
  phone        String
  userId       Int
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdAt    DateTime @default(now())
  uploadedFile Bytes?
}

model Order {
  id        Int     @id @default(autoincrement())
  orderCode String  @unique
  name      String?
  phone     String?
  plan      String
  amount    String
  status    String
  date      String
  userId    Int
  user      User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  timestamp BigInt  @default(0) @db.BigInt
  deleted   Boolean @default(false)
}

model VerificationBatch {
  id               Int           @id @default(autoincrement())
  name             String?
  source           String
  includeOnlyValid Boolean       @default(false)
  total            Int
  validCount       Int
  invalidCount     Int
  riskyCount       Int
  createdAt        DateTime      @default(now())
  results          BatchResult[]
  userId           Int // âœ… Required
  user             User          @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([createdAt])
}

model BatchResult {
  id             Int               @id @default(autoincrement())
  batchId        Int
  email          String
  status         String
  score          Int
  syntax_valid   Boolean
  domain_valid   Boolean
  mailbox_exists Boolean?
  catch_all      Boolean?
  disposable     Boolean
  role_based     Boolean
  greylisted     Boolean
  free_provider  Boolean?
  provider       String?
  mx             String?
  error          String?
  createdAt      DateTime          @default(now())
  userId         Int // âœ… Required
  user           User              @relation(fields: [userId], references: [id], onDelete: Cascade)
  batch          VerificationBatch @relation(fields: [batchId], references: [id], onDelete: Cascade)

  @@index([email])
}

model Verification {
  id             Int      @id @default(autoincrement())
  email          String // ðŸ‘ˆ Removed @unique
  status         String
  score          Int?
  syntax_valid   Boolean?
  domain_valid   Boolean
  mailbox_exists Boolean?
  catch_all      Boolean?
  disposable     Boolean
  role_based     Boolean
  greylisted     Boolean
  free_provider  Boolean?
  provider       String?
  mx             String[]
  error          String?
  createdAt      DateTime @default(now())
  userId         Int
  user           User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, email]) // âœ… Add this
}

model FrontendVerification {
  id             Int      @id @default(autoincrement())
  email          String
  status         String
  score          Int?
  syntax_valid   Boolean?
  domain_valid   Boolean
  mailbox_exists Boolean?
  catch_all      Boolean?
  disposable     Boolean
  role_based     Boolean
  greylisted     Boolean
  free_provider  Boolean?
  provider       String?
  mx             String[]
  error          String?
  ip             String?
  source         String?
  createdAt      DateTime @default(now())
}

model MmsCampaign {
  id         Int            @id @default(autoincrement())
  name       String
  message    String
  mediaUrl   String
  createdAt  DateTime       @default(now())
  recipients MmsRecipient[]
}

model MmsRecipient {
  id            Int         @id @default(autoincrement())
  phone         String
  mmsCampaignId Int
  mmsCampaign   MmsCampaign @relation(fields: [mmsCampaignId], references: [id])
}

model Payment {
  id                       Int       @id @default(autoincrement())
  userId                   Int
  email                    String
  name                     String
  emailVerificationCredits Int       @default(0)
  emailSendCredits         Int       @default(0)
  smsCredits               Int?      @default(0)
  whatsappCredits          Int?      @default(0)
  transactionId            String    @unique
  planName                 String
  planType                 String
  provider                 String
  amount                   Float
  currency                 String
  planPrice                Float
  discount                 Float?
  paymentMethod            String
  cardLast4                String?
  billingAddress           String?
  paymentDate              DateTime
  nextPaymentDate          DateTime?
  status                   String
  notified                 Boolean   @default(false)
  createdAt                DateTime  @default(now())
  updatedAt                DateTime  @updatedAt

  // âœ… Enable cascade delete
  User User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model ScheduledCampaign {
  id                 Int       @id @default(autoincrement())
  userId             Int
  campaignName       String
  subject            String
  fromName           String
  fromEmail          String
  recipients         Json
  template           String?
  canvasData         Json?
  scheduleType       String
  scheduledDateTime  DateTime?
  timezone           String?
  recurringFrequency String?
  recurringDays      String?
  recurringEndDate   DateTime?
  status             String
  error              String?
  createdAt          DateTime  @default(now())
  updatedAt          DateTime  @updatedAt

  // Add relation to User if you have User model
  user      User        @relation(fields: [userId], references: [id])
  SentEmail SentEmail[]
}

model SentEmail {
  id         Int               @id @default(autoincrement())
  campaignId Int
  email      String
  status     String // sent | failed
  error      String?
  sentAt     DateTime          @default(now())
  campaign   ScheduledCampaign @relation(fields: [campaignId], references: [id])
}

model Campaign {
  id                 Int       @id @default(autoincrement())
  userId             Int
  name               String
  subject            String
  fromEmail          String
  fromName           String
  scheduleType       String    @default("immediate") // "immediate", "scheduled", "recurring"
  designJson         String?   @db.Text
  recipientsJson     String?   @db.Text // âœ… NEW: Store recipients for scheduled/recurring
  scheduledAt        DateTime?
  recurringFrequency String? // "daily", "weekly", "monthly"
  recurringDays      String? // JSON array of days for weekly
  recurringEndDate   DateTime?
  lastSentAt         DateTime? // âœ… NEW: Track last send time for recurring
  sentCount          Int       @default(0)
  openCount          Int       @default(0)
  clickCount         Int       @default(0)
  status             String
  createdAt          DateTime  @default(now())
  updatedAt          DateTime  @updatedAt

  user          User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  events        CampaignEvent[]
  AutomationLog AutomationLog[]

  @@index([userId])
}

model AutomationLog {
  id           Int      @id @default(autoincrement())
  userId       Int
  campaignId   Int?
  campaignName String
  status       String // 'scheduled', 'sent', 'failed', 'processing', 'paused'
  message      String
  error        String?
  createdAt    DateTime @default(now())

  user     User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  campaign Campaign? @relation(fields: [campaignId], references: [id], onDelete: Cascade)
}

model CampaignEvent {
  id         Int      @id @default(autoincrement())
  campaignId Int
  userId     Int
  email      String
  type       String // "delivered", "open", "click", "bounce", "failed", etc.
  timestamp  DateTime @default(now())
  metadata   String? // âœ… JSON string for additional data
  url        String? // For click events
  userAgent  String?
  ip         String?
  sgEventId  String?  @unique // Prevent duplicate events

  campaign Campaign @relation(fields: [campaignId], references: [id], onDelete: Cascade)
  user     User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([campaignId, type])
  @@index([email])
  @@index([sgEventId])
}

model CampaignVerifiedEmail {
  id                Int       @id @default(autoincrement())
  email             String    @unique
  fromName          String
  userId            Int
  verificationToken String?   @unique
  isVerified        Boolean   @default(false)
  verifiedAt        DateTime?
  expiresAt         DateTime?
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  @@unique([email, userId], name: "email_userId")
  @@map("campaign_verified_emails")
}

model VerifiedSender {
  id               Int       @id @default(autoincrement())
  email            String
  fromName         String?
  verified         Boolean   @default(false)
  verifiedAt       DateTime?
  sendgridSenderId Int?
  sendgridStatus   String?
  token            String?
  tokenExpiresAt   DateTime?
  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt

  userId Int
  user   User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([email, userId])
  @@index([userId])
}

model CustomRecord {
  id           String   @id @default(cuid())
  recordType   String
  name         String?
  email        String?
  phone        String?
  company      String?
  website      String?
  source       String   @default("manual")
  status       String?
  score        Int?
  last         String?
  customFields Json?
  userId       Int // must match User.id
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("custom_records")
}

model TwilioConfig {
  id               Int      @id @default(autoincrement())
  userId           Int      @unique // one config per user
  accountSid       String
  authToken        String
  whatsappNumber   String?
  smsNumber        String?
  messagingService String? // optional: for Twilio Messaging Service SID
  isActive         Boolean  @default(true)
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  // Relation to User
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model WhatsappCampaign {
  id         Int                 @id @default(autoincrement())
  userId     Int
  name       String
  message    String
  mediaUrl   String?
  schedule   DateTime? // for scheduled send
  createdAt  DateTime            @default(now())
  updatedAt  DateTime            @updatedAt
  status     String              @default("queued") // queued | sent | failed
  recipients WhatsappRecipient[]
  user       User                @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model SmsCampaign {
  id         Int            @id @default(autoincrement())
  userId     Int
  name       String
  message    String
  schedule   DateTime?
  createdAt  DateTime       @default(now())
  updatedAt  DateTime       @updatedAt
  status     String         @default("queued")
  recipients SmsRecipient[]
  user       User           @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model WhatsappRecipient {
  id                 Int              @id @default(autoincrement())
  phone              String
  status             String? // sent | delivered | failed
  error              String?
  whatsappCampaignId Int
  campaign           WhatsappCampaign @relation(fields: [whatsappCampaignId], references: [id], onDelete: Cascade)
}

model SmsRecipient {
  id            Int         @id @default(autoincrement())
  phone         String
  status        String?
  error         String?
  smsCampaignId Int
  campaign      SmsCampaign @relation(fields: [smsCampaignId], references: [id], onDelete: Cascade)
}
